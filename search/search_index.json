{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This tool is a complete framework to carry electrical simulations of hardware implemented Spiking Neural Network (SNN) whose synapses are based on Magnetic Tunnel Junctions MTJs.  The non volatile MTJ memories and their involvment inside the network provides an alternative computing architecture to the Von-Neurman memroy bottelnec. moreover, the operating mechanism of SNN by spikes leads to an energy efficient hardware. </p> <p>This framework helps making together all the parts required to run Spice simulations using <code>Cadence Spectre</code> simulator. It includes the following device Verilog-A description models: </p> <ol> <li><code>MTJ model</code> : a model that integrates the electrical and magnetic behavior of the MTJ and simulate its use as a two state memory device. Credits to Fert Beijing Institut, China.</li> <li><code>input neuron model</code> : a spiking neuron model developed in-house to stand as an input neuron that incodes the input images and feed thme to the network.</li> <li><code>output neuron model</code> : a leak integrate and fire neuron model that is used as an output neuron. it is developed in-house.</li> </ol> <p>Along with these necessary device descriptions, a netlist that describes the full network is required. The framework allows an automatic generation of a netlist that describes the full SNN network of any size. The operator only needs to input some basic information like the number of input and output neurons, the number of MTJs/synapse, a time window during whitch an input image is presented to the network, so that the framework can generate the corresponding netlist. </p> <p>Once the netlist has been generated, the simulation is lanched automatically in <code>Spectre</code>. It inputs the image pixels to the netowrk, the input neurons spike according to a given coding and signal is fed forward in form of current that allwos the network to learn the paterns using the Spike Timing Dependent Plasticity STDP rule which is specific to SNNs. The framework tracks the history of each synapse and neuron in the network. It finally allows diffrent ploting and visualisation fonctionalities. </p> <p>The following diagram summurises every file involved in the simulaiton of SNN online training and it output visualisation, and how they interact in an automatic way. </p> <p></p>"},{"location":"net_generator/","title":"Net generator","text":"<p>Spice simulation with Spectre simulator requires a netlist file that includes the description of all the components of the circuit, and describes how these componenents are wired. The framework allows flexible geneartion of the netlist according to the desired networkd to be simulated. Only some network parameters should be given, for the corresponding netlist to be automatically generated.  The follwoing module <code>net_generator.py</code> which contains diffrent classes is responsible of generating the netlist.  Circuit componenents are mangaged by the follwing classes : <code>Synapse</code>, <code>Synapse_subskt</code>, <code>Input_neuron</code>, <code>Output_neuron</code>, each contains a <code>generate_netlist_bloc</code> method that sets a string template bloc specific to that componenent and which should be added to the netlist file.  The class <code>Netlist</code> concatinates the instances of the componenets in a list, and generates a string bloc of a single componenent ready to be inserted in the final netlist. The class <code>NetworkGenerator</code> is the main class that assembles all the components by iterating the appending method of <code>Netlist</code> class. and trigers the netlist generation method of <code>Netlist</code>.  Finally <code>Separotor</code> is a class to add a separation between a group of similar componenets for a bette rformatting.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Input_neuron","title":"<code>Input_neuron</code>","text":"<p>A class to specify a netlist bloc that describes an input neuron of the SNN,  a method takes a template, adds information of the current neuron  (neuron index, number of spikes associated to that input neuron, the duration of a single input spike,  and the duration of presenting an input example to the netowrk). That sting bloc will then be included in the final netlist.</p> <p>Attributes:</p> Name Type Description <code>input_index</code> <code>[int]</code> <p>The index of this input neuron.</p> <code>n_spikes</code> <code>[int]</code> <p>The number of spikes this neuron will generate.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Input_neuron--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that input neuron in the final netlist file.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Input_neuron:\n\"\"\"\n    A class to specify a netlist bloc that describes an input neuron of the SNN, \n    a method takes a template, adds information of the current neuron \n    (neuron index, number of spikes associated to that input neuron, the duration of a single input spike, \n    and the duration of presenting an input example to the netowrk). That sting bloc will then be included\n    in the final netlist.\n    Attributes:\n        input_index [int]: The index of this input neuron.\n        n_spikes [int]: The number of spikes this neuron will generate.\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that input neuron in the final netlist file. \n    \"\"\"\ndef __init__(self, input_index, n_spikes):\nself.input_index = input_index\nself.n_spikes = n_spikes\ndef generate_netlist_bloc(self):\ntemplate = ( \"input_neuron{} (input{} 0) Input_neuron r=0 n_spikes={} spike_duration=spike_duration presenting_time=sim_time \\n\") \nreturn template.format(self.input_index, self.input_index, self.n_spikes)\n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.Netlist","title":"<code>Netlist</code>","text":"<p>A class which assemles the instances of all the components, it then generates the netlist file add_component is a method that appends the instances of the componenets in one list called components. generate_netlist_file is a method that generates the diffrent parts of the netlist by using the generate_netlist_bloc() which is comment to all the components classes. </p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>[str]</code> <p>The path to the file where the netlist will be written.</p> <code>components</code> <code>[list]</code> <p>The list of components instances (synapses, neurons, etc.).</p>"},{"location":"net_generator/#snn_simulator.net_generator.Netlist--methods","title":"Methods","text":"<p>add_component(component):     appends the instance of each omponenent to the components list. generate_netlist_file():     Writes the netlist to a file.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Netlist:\n\"\"\"\n    A class which assemles the instances of all the components, it then generates the netlist file\n    add_component is a method that appends the instances of the componenets in one list called components.\n    generate_netlist_file is a method that generates the diffrent parts of the netlist by using the generate_netlist_bloc()\n    which is comment to all the components classes. \n    Attributes:\n        file_path [str]: The path to the file where the netlist will be written.\n        components [list]: The list of components instances (synapses, neurons, etc.).\n    Methods\n    -------\n    add_component(component):\n        appends the instance of each omponenent to the components list.\n    generate_netlist_file():\n        Writes the netlist to a file.\n    \"\"\"\ndef __init__(self, file_path):\nself.file_path = file_path\nself.components = [] # The netlist will be built inside this list\ndef add_component(self, component):\nself.components.append(component)                       \ndef generate_netlist_file(self):\ncontent = \"\"\nwith open(\"netlist_ocn/netlist\", \"r\") as file0:\ncontent += file0.read()\nfor component in self.components:\ncontent += component.generate_netlist_bloc()        # use the class instances of componenets stroed in components to generate template and add it to content\nwith open(self.file_path, \"w\") as file1:\nfile1.write(content)\n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.NetworkGenerator","title":"<code>NetworkGenerator</code>","text":"<p>The main class that generates all the netlist file, it is based on the Netlist class, It iterates over all the components by group of similar ones, it appends instances of  each component to the components list, while adding separation formatting between groups of similar components.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>[str]</code> <p>The path to the file where the netlist will be written.</p> <code>num_input</code> <code>[int]</code> <p>The number of input neurons in the network.</p> <code>num_output</code> <code>[int]</code> <p>The number of output neurons in the network.</p> <code>num_cells</code> <code>[int]</code> <p>The number of MTJ cells in each synapse.</p> <code>netlist</code> <code>[Netlist]</code> <p>The netlist object that will be written to a file.</p> <code>n_spik_vec</code> <code>[list of int]</code> <p>A list containing the number of spikes for each input neuron.</p>"},{"location":"net_generator/#snn_simulator.net_generator.NetworkGenerator--methods","title":"Methods","text":"<p>generate_netlist_file():     similar to the generate_netlist_file of the Netlist class, but instead of generating a single component,      it operates globally, ie: it generates the whole netlist by iterating through the method of Netlist class.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class NetworkGenerator:\n\"\"\"\n    The main class that generates all the netlist file, it is based on the Netlist class,\n    It iterates over all the components by group of similar ones, it appends instances of \n    each component to the components list, while adding separation formatting between groups of similar components.\n    Attributes:\n        file_path [str]: The path to the file where the netlist will be written.\n        num_input [int]: The number of input neurons in the network.\n        num_output [int]: The number of output neurons in the network.\n        num_cells [int]: The number of MTJ cells in each synapse.\n        netlist [Netlist]: The netlist object that will be written to a file.\n        n_spik_vec [list of int]: A list containing the number of spikes for each input neuron.\n    Methods\n    -------\n    generate_netlist_file():\n        similar to the generate_netlist_file of the Netlist class, but instead of generating a single component, \n        it operates globally, ie: it generates the whole netlist by iterating through the method of Netlist class.\n    \"\"\"\ndef __init__(self, file_path, num_input, num_output, num_cells, n_spik_vec):\nself.file_path = file_path\nself.num_input = num_input\nself.num_output = num_output\nself.num_cells = num_cells\nself.netlist = Netlist(file_path)\nself.n_spik_vec = n_spik_vec # a list of a flattned array, containing n_spikes for each input neuron\ndef generate_netlist_file(self):\nself.netlist.add_component(Synapse_subskt(self.num_cells))\nself.netlist.add_component(Separator())\nnum_synapses = self.num_input * self.num_output\n# add the synapses \nfor i in range(1, num_synapses + 1):\ninput_index = (i - 1) % self.num_input + 1\noutput_index = (i - 1) // self.num_input + 1\nsynapse = Synapse(input_index, output_index, self.num_cells)\nself.netlist.add_component(synapse)\nself.netlist.add_component(Separator())\n# add input neurons\nfor i in range(1, self.num_input + 1):\ninput_neuron = Input_neuron(i, self.n_spik_vec[i-1])\nself.netlist.add_component(input_neuron)\nself.netlist.add_component(Separator())\n# add output neurons \nfor i in range(1, self.num_output + 1):\noutput_neuron = Output_neuron(i)\nself.netlist.add_component(output_neuron)\nself.netlist.generate_netlist_file()\n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.Output_neuron","title":"<code>Output_neuron</code>","text":"<p>A class to specify a netlist bloc of an output neuron of the SNN,  a method takes a template, adds information of the current neuron  (neuron index, membrane threshold). That sting bloc will then be included in the final netlist.</p> <p>Attributes:</p> Name Type Description <code>output_index</code> <code>[int]</code> <p>The index of this output neuron.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Output_neuron--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that output neuron in the final netlist file.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Output_neuron:\n\"\"\"\n    A class to specify a netlist bloc of an output neuron of the SNN, \n    a method takes a template, adds information of the current neuron \n    (neuron index, membrane threshold). That sting bloc will then be included\n    in the final netlist.\n    Attributes:\n        output_index [int]: The index of this output neuron.\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that output neuron in the final netlist file. \n    \"\"\"\ndef __init__(self, output_index):\nself.output_index = output_index \ndef generate_netlist_bloc(self):\ntemplate = ( \"output_neuron{} (output{}) LIF_verilog_extcap mem_vth=mem_vth\\n\" )\nreturn template.format(self.output_index, self.output_index)\n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.Separator","title":"<code>Separator</code>","text":"<p>A class to seperate between componenets in the netlist for a better formatting.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Separator--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a separation as a string.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Separator:\n\"\"\"\n    A class to seperate between componenets in the netlist for a better formatting.\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a separation as a string.\n    \"\"\"\ndef generate_netlist_bloc(self):\nreturn \"\\n//===================================================\\n\"     \n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.Synapse","title":"<code>Synapse</code>","text":"<p>A class to specify a netlist bloc that describes an MTJ-based synapse of the SNN,  generate_netlist_bloc is a method that returns as string which represents a template  bloc of the synapse to be included in the netlist later. It personalizes the synapse at the current iteration by adding its specific informatio (connected neurons, number  of MTJs per synapse, initialized states, seeds,... ). The synapse template calls the  compound_synapse subcircuit which should be included once in the head of the netlist.</p> <p>Attributes:</p> Name Type Description <code>input_index</code> <code>[int]</code> <p>The index of the input neuron connected to this synapse.</p> <code>output_index</code> <code>[int]</code> <p>The index of the output neuron connected to this synapse.</p> <code>paps</code> <code>[list of int]</code> <p>The list of initial states of free layers for each MTJ in the synapse. (0 parallel, 1 anti-parallel).</p> <code>seeds</code> <code>[list of int]</code> <p>The list of seed values used for stochasticity for each MTJ in the synapse.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Synapse--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that synapse in the final netlist file.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Synapse:\n\"\"\"\n    A class to specify a netlist bloc that describes an MTJ-based synapse of the SNN, \n    generate_netlist_bloc is a method that returns as string which represents a template \n    bloc of the synapse to be included in the netlist later. It personalizes the synapse\n    at the current iteration by adding its specific informatio (connected neurons, number \n    of MTJs per synapse, initialized states, seeds,... ). The synapse template calls the \n    compound_synapse subcircuit which should be included once in the head of the netlist.\n    Attributes:\n        input_index [int]: The index of the input neuron connected to this synapse.\n        output_index [int]: The index of the output neuron connected to this synapse.\n        paps [list of int]: The list of initial states of free layers for each MTJ in the synapse. (0 parallel, 1 anti-parallel).\n        seeds [list of int]: The list of seed values used for stochasticity for each MTJ in the synapse.\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that synapse in the final netlist file. \n    \"\"\"\ndef __init__(self, input_index, output_index, num_cells):\nself.input_index = input_index\nself.output_index = output_index\n#self.paps = [i%2 for i in range(num_cells)]                 # alternate 0&amp;1 in the MTJs of the synapse\nself.paps = [random.randint(0, 1) for _ in range(num_cells)] #initialize randamely\nself.seeds = [random.randint(0, 9999) for _ in range(num_cells)]\ndef generate_netlist_bloc(self):                 \ntemplate = \"synapse{}_{} (input{} output{}) compound_synapse \"\npaps_str = \" \".join(\"PAP{}={}\".format(i + 1, pap) for i, pap in enumerate(self.paps))\nseeds_str = \" \".join(\"seed{}={}\".format(i + 1, seed) for i, seed in enumerate(self.seeds))\nreturn template.format(\nself.input_index, self.output_index, self.input_index, self.output_index\n) + paps_str + \" \\\\\\n\\t\\t\" + seeds_str + \"\\n\"\n</code></pre>"},{"location":"net_generator/#snn_simulator.net_generator.Synapse_subskt","title":"<code>Synapse_subskt</code>","text":"<p>A class to specify a netlist bloc of the synapse subcircuit named compound_synapse,  which will be called by all the synapses. It is composed of multiple MTJs (the number is given as attribute),  and it makes call of the cellPMAMTJ subcircuit which is predefined in the initial netlist file. generate_netlist_bloc is a method that returns the subcircuit template to be included in the netlist. It takes an initial template, adds parameters to it : either to set stochasticity, variability, temperature and its variation or not, and sets as parameters the initial state of the MTJ, and the seed. </p> <p>Attributes:</p> Name Type Description <code>num_cells</code> <code>[int]</code> <p>The number of MTJ cells in each synapse.</p>"},{"location":"net_generator/#snn_simulator.net_generator.Synapse_subskt--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to the compound_synapse subcircuit in the final netlist file.</p> Source code in <code>snn_simulator/net_generator.py</code> <pre><code>class Synapse_subskt:\n\"\"\"\n    A class to specify a netlist bloc of the synapse subcircuit named compound_synapse, \n    which will be called by all the synapses. It is composed of multiple MTJs (the number is given as attribute), \n    and it makes call of the cellPMAMTJ subcircuit which is predefined in the initial netlist file.\n    generate_netlist_bloc is a method that returns the subcircuit template to be included in the netlist.\n    It takes an initial template, adds parameters to it : either to set stochasticity, variability,\n    temperature and its variation or not, and sets as parameters the initial state of the MTJ, and the seed. \n    Attributes:\n        num_cells [int]: The number of MTJ cells in each synapse.\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to the compound_synapse subcircuit in the final netlist file. \n    \"\"\"\ndef __init__(self, num_cells):\nself.num_cells = num_cells\ndef generate_netlist_bloc(self):\ntemplate = (\"subckt compound_synapse ter1 ter2 \\n\"\n\"parameters {} \\n\")\nparameters = \" \".join([\"seed{}\".format(i+1) for i in range(self.num_cells)] +\n[\"PAP{}\".format(i+1) for i in range(self.num_cells)])\ncells = \"\"\nfor i in range(self.num_cells):\ncell_line = (\"\\tcell{} (ter1 ter2) cellPMAMTJ   param1=gl_STO   param2=gl_RV   param3=gl_T   param4=gl_Temp_var   \"\n\"param5=PAP{}   param6=seed{}\\n\".format(i+1, i+1, i+1))\ncells += cell_line\nnetlist_bloc = template.format( parameters) + cells + \"ends compound_synapse\\n\"\nreturn netlist_bloc\n</code></pre>"}]}