{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"SNN Training Framework"},{"location":"#introduction","title":"Introduction","text":"<p>The SNN Training Framework streamlines the design, training, and analysis of Spiking Neural Networks (SNNs) with electrical simulations. These simulations aim to validate the concept of hardware implementation of SNNs with spintronic synapsees, which are energy effecient and allow unsupervised learning. The tool automates the generation of netlists for SPICE, running simulations with <code>Cadence Spectre</code>, and analyzing the results. It facilitates efficient exploration of various SNN configurations with a high degree of customization, with miminum intervintion from the user.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Automated Netlist Generation: Automatically generates detailed netlists essential for accurately modeling SNN behavior at the device level, using customizable parameters.</li> <li>Integration with SPICE Simulator: Seamlessly integrates with <code>Cadence Ocean</code> tool and uses <code>Spectre</code> simulator, allowing electrical simulation, without much worrying about the design and resutls handelign. </li> <li>Parallel Processing Capabilities: Supports multiprocessing to conduct parallel simulations and parametric analysis, crucial for simultaneous and fast design exploration of different SNNs. </li> <li>Performance Analysis: Provides comprehensive post-simulation results, including synaptic weight evolution, neuron membrane potential dynamics, and overall learning performance, with minimal user input beyond the initial setup.</li> </ul>"},{"location":"#project-background","title":"Project Background","text":"<p>Simulation environments for SNNs vary widely based on their objectives, from functional to behavioral simulations. Electrical simulations with SPICE are critical for hardware implementation as they model synaptic conductance and neuron membrane potentials using actual voltages and currents, providing essential validation for hardware implementations. This project was initially concieved during a PhD to automate design explorations that simulate training of SNNs with MTJ-based synapses, with a specific learing rule, but can be adapted for other type of synapses and learning rules. Conducting SNN training in SPICE validates learning rules like STDP and demonstrates the feasibility of online learning through dynamic conductance changes in spintronic synapses. Although SPICE simulations are computationally expensive, they offer rigorous, hardware-accurate results suitable for small networks.</p> <p>Development and training of SNNs at the device level pose some challenges, especially in network design, which often involves creating complex schematics or manually writing netlists. This process is time-consuming and prone to errors. This framework addresses these challenges by automating the design and training of SNNs with electrical simulations. By automating these processes, we save time and reduce the potential for human error, making it significantly easier to manage and explore various network configurations efficiently.</p>"},{"location":"#overview","title":"Overview","text":"<p>The tool handles the design and netlist creation, while the actual simulations are executed in SPICE. The design consists of input and output neurons described in Verilog-A, fully conencted by spintornic synapses. Each synapse is composed of multiple Magnetic Tunnel Junction (MTJs) connected in parallel. The learning rule is derived from the physical behaviour of the stochastic synapse and is labeled Bi-Sigmoid STDP. </p>"},{"location":"#device-models","title":"Device Models","text":"<p>The framework includes the following Verilog-A device description models:</p> <ol> <li>MTJ Model: Integrates the electrical and magnetic behavior of the MTJ and simulates its use as a two-state memory device. </li> <li>Input Neuron Model: A spiking neuron model that encodes the input images and feed them to the network.</li> <li>Output Neuron Model: A leaky integrate-and-fire neuron model used as an output neuron.</li> </ol>"},{"location":"#netlist-generation","title":"Netlist Generation","text":"<p>Along with these necessary device descriptions, a netlist that describes the full network is required. The framework allows automatic generation of a netlist for SNNs of any size. The operator only needs to input basic information such as the number of input and output neurons, the number of MTJs per synapse, and a time window during which an input image is presented to the network. The framework then generates the corresponding netlist.</p>"},{"location":"#simulation-and-analysis","title":"Simulation and Analysis","text":"<p>Once the netlist has been generated, the simulation is launched automatically in <code>Spectre</code>. It inputs the image pixels to the network, the input neurons spike according to a given coding, and the signal is fed forward in the form of current, allowing the network to learn the patterns using the B2STDP rule, which is specific to SNNs. The framework tracks the history of each synapse and neuron in the network and provides different plotting and visualization functionalities.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#1-snn-simulator","title":"1. SNN Simulator","text":"<p>This is the main module that orchestrates the simulation process of SNN. It handles the creation of input images, netlist generation, parameter substitution,  and execution of the simulation, along with the collection of results.</p> This module <ol> <li>Accepts user-specificatied parameter combinations for different SNN designs.</li> <li>Loads the generated input images, flattens them, and uses frequency coding proportional to pixel intensity</li> <li>Generates files and process-specific directory for each SNN simulation named with the date, process ID, and parameter details </li> <li>Creates the netlist for each simulation using the net_generator module.</li> <li>Substitutes parameters into the OCEAN script template and launches the SPICE simulation using the subst_run module. </li> <li>Collects and saves the waveforms results of the selected signals.</li> <li>Executes the simulations of different SNN designs in parallel.</li> </ol>"},{"location":"api/#src.snn_simulator.main","title":"<code>main()</code>","text":"<p>Main function to run all simulations using multiprocessing.</p> Steps <ol> <li>Distribute parameter combinations across multiple processes.</li> <li>Run simulations in parallel.</li> <li>Measure and print the total simulation time.</li> </ol> Source code in <code>src/snn_simulator.py</code> <pre><code>def main():\n    \"\"\"\n    Main function to run all simulations using multiprocessing.\n\n    Steps:\n        1. Distribute parameter combinations across multiple processes.\n        2. Run simulations in parallel.\n        3. Measure and print the total simulation time.\n    \"\"\"\n    with Pool() as p:\n        p.map(run_simulation, param_combinations)  # Distribute combinations sets and run\n        simul_t = datetime.timedelta(seconds=tm.time() - start_time)\n    print(f\" --- The simulation finished after {simul_t} - at {datetime.datetime.now()} ---\")\n</code></pre>"},{"location":"api/#src.snn_simulator.run_simulation","title":"<code>run_simulation(params)</code>","text":"<p>Runs a single SNN simulation with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>A dictionary containing global and local simulation parameters.</p> required Steps <ol> <li>Load and flatten input image.</li> <li>Calculate the number of spikes for each input neuron based on pixel intensity.</li> <li>Generate and prepare directories and files for the simulation.</li> <li>Create the netlist for the simulation.</li> <li>Substitute parameters into the OCEAN script and run the simulation.</li> <li>Clean up temporary files.</li> </ol> Source code in <code>src/snn_simulator.py</code> <pre><code>def run_simulation(params):\n    \"\"\"\n    Runs a single SNN simulation with the given parameters.\n\n    Args:\n        params (dict): A dictionary containing global and local simulation parameters.\n\n    Steps:\n        1. Load and flatten input image.\n        2. Calculate the number of spikes for each input neuron based on pixel intensity.\n        3. Generate and prepare directories and files for the simulation.\n        4. Create the netlist for the simulation.\n        5. Substitute parameters into the OCEAN script and run the simulation.\n        6. Clean up temporary files.\n    \"\"\"\n    # Load and flatten spiking neurons intensity\n    input_data = np.load(f'./input_images/letter_imgs/generated_{params[\"inp_img\"]}.npy')\n    flat_input_data = input_data.flatten()\n    # Use frequency coding proportional to pixel intensity + baseline\n    n_spik_vec = params['cod_base'] + params['cod_max'] * (flat_input_data / 255.0)    \n    params['num_input'] = len(flat_input_data)\n\n    # Create a string that contains result signals, to insert in .ocn file \n    save_states = \"\" \n    for i in range(1, params['num_input'] * params['num_output'] + 1):\n        input_index = (i - 1) % params['num_input'] + 1\n        output_index = (i - 1) // params['num_input'] + 1\n        for j in range(1, params['num_cells'] + 1):\n            save_states += f'v(\"synapse{input_index}_{output_index}.cell{j}.I:ix\") '\n            if j &lt; params['num_cells']:\n                save_states += '+'\n\n    base_dir = os.path.abspath(\"../../snn_sim_folders/\")\n    # Format date and time as a string in the format 'MMDD_HHMM'\n    now = datetime.datetime.now()\n    date = now.strftime(\"%m%d_%H%M\")     \n    #process_dir = f\"dat_{date}_pross_{os.getpid()}\"          # name the folder with date,time &amp; process\n    process_dir = f\"dat_{date}_pross_{os.getpid()}_let{params['inp_img']}_dev{params['dev']}_cells{params['num_cells']}\" #include the paramters with date &amp; process\n\n    abs_process_dir = os.path.join(base_dir, process_dir)\n\n    # Create a process-specific directory for simulation files and results\n    if not os.path.exists(abs_process_dir):   \n        os.mkdir(abs_process_dir)             \n        os.mkdir(abs_process_dir + \"/netlist_ocn\")\n    copy_tree(\"./netlist_ocn\", f\"{abs_process_dir}/netlist_ocn\")   \n    netlist = os.path.join(abs_process_dir, \"netlist_ocn\", \"netlist\")\n    results_file = os.path.join(abs_process_dir, \"results.txt\") \n\n    # Params to include in .ocn file\n    params[\"netlist\"] = netlist  # Path to the complete netlist file \n    params[\"process_dir\"] = abs_process_dir  # Path to simulation process dir\n    params[\"results_file\"] = results_file  # Path to the file where results are written \n    params[\"save_states\"] = save_states  # A string containing signals to be written in results file\n\n    random.seed(10)\n    network_generator = NetworkGenerator(netlist, params['num_input'], params['num_output'], params['num_cells'], n_spik_vec)\n    network_generator.generate_netlist_file()  # The complete netlist file is created \n\n    updated_template_file = os.path.join(abs_process_dir, \"updated_template.ocn\")\n    log_file = os.path.join(abs_process_dir, \"oceanScript.log\") \n    subst_run.substitute_templ(\"./oceanScript.ocn\", updated_template_file, params)\n    subst_run.exec_cmd(f\"ocean -nograph &lt; {updated_template_file} &gt; {log_file}\") \n    shutil.rmtree(f\"{abs_process_dir}/psf\")  # Remove the psf directory\n</code></pre>"},{"location":"api/#2-network-generation","title":"2. Network Generation","text":"<p>Spice simulation with Spectre simulator requires a netlist file that includes the description of all the components of the circuit, and describes how these componenents are wired. The framework allows flexible geneartion of the netlist according to the desired network to be simulated. Only some network parameters should be given, for the corresponding netlist to be automatically generated.  The follwoing module <code>net_generator.py</code> which contains diffrent classes is responsible of generating the netlist. Circuit componenents are mangaged by the follwing classes : <code>Synapse</code>, <code>Synapse_subskt</code>, <code>Input_neuron</code>, <code>Output_neuron</code>, each contains a <code>generate_netlist_bloc</code> method that sets a string template bloc specific to that componenent and which should be added to the netlist file. The class <code>Netlist</code> concatinates the instances of the componenets in a list, and generates a string bloc of a single componenent ready to be inserted in the final netlist. The class <code>NetworkGenerator</code> is the main class that assembles all the components by iterating the appending method of <code>Netlist</code> class. and trigers the netlist generation method of <code>Netlist</code>. Finally <code>Separotor</code> is a class to add a separation between a group of similar componenets for a bette rformatting.</p>"},{"location":"api/#src.net_generator.Input_neuron","title":"<code>Input_neuron</code>","text":"<p>A class to specify a netlist bloc that describes an input neuron of the SNN,  a method takes a template, adds information of the current neuron  (neuron index, number of spikes associated to that input neuron, the duration of a single input spike,  and the duration of presenting an input example to the netowrk). That sting bloc will then be included in the final netlist.</p> <p>Attributes:</p> Name Type Description <code>input_index</code> <code>[int]</code> <p>The index of this input neuron.</p> <code>n_spikes</code> <code>[int]</code> <p>The number of spikes this neuron will generate.</p>"},{"location":"api/#src.net_generator.Input_neuron--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that input neuron in the final netlist file.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Input_neuron:\n    \"\"\"\n    A class to specify a netlist bloc that describes an input neuron of the SNN, \n    a method takes a template, adds information of the current neuron \n    (neuron index, number of spikes associated to that input neuron, the duration of a single input spike, \n    and the duration of presenting an input example to the netowrk). That sting bloc will then be included\n    in the final netlist.\n\n    Attributes:\n        input_index [int]: The index of this input neuron.\n        n_spikes [int]: The number of spikes this neuron will generate.\n\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that input neuron in the final netlist file. \n    \"\"\"\n\n    def __init__(self, input_index, n_spikes):\n        self.input_index = input_index\n        self.n_spikes = n_spikes\n\n    def generate_netlist_bloc(self):\n\n        template = ( \"input_neuron{} (input{} 0) Input_neuron r=0 n_spikes={} spike_duration=spike_duration presenting_time=sim_time \\n\") \n        return template.format(self.input_index, self.input_index, self.n_spikes)\n</code></pre>"},{"location":"api/#src.net_generator.Netlist","title":"<code>Netlist</code>","text":"<p>A class which assemles the instances of all the components, it then generates the netlist file add_component is a method that appends the instances of the componenets in one list called components. generate_netlist_file is a method that generates the diffrent parts of the netlist by using the generate_netlist_bloc() which is commun to all the components classes. </p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>[str]</code> <p>The path to the file where the netlist will be written.</p> <code>components</code> <code>[list]</code> <p>The list of components instances (synapses, neurons, etc.).</p>"},{"location":"api/#src.net_generator.Netlist--methods","title":"Methods","text":"<p>add_component(component):     appends the instance of each omponenent to the components list. generate_netlist_file():     Writes the netlist to a file.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Netlist:\n    \"\"\"\n    A class which assemles the instances of all the components, it then generates the netlist file\n    add_component is a method that appends the instances of the componenets in one list called components.\n    generate_netlist_file is a method that generates the diffrent parts of the netlist by using the generate_netlist_bloc()\n    which is commun to all the components classes. \n\n    Attributes:\n        file_path [str]: The path to the file where the netlist will be written.\n        components [list]: The list of components instances (synapses, neurons, etc.).\n\n    Methods\n    -------\n    add_component(component):\n        appends the instance of each omponenent to the components list.\n    generate_netlist_file():\n        Writes the netlist to a file.\n    \"\"\"\n\n    def __init__(self, file_path):\n        self.file_path = file_path\n        self.components = [] # The netlist will be built inside this list\n\n    def add_component(self, component):\n        self.components.append(component)                       \n\n    def generate_netlist_file(self):\n        content = \"\"\n        with open(\"netlist_ocn/netlist\", \"r\") as file0:\n            content += file0.read()\n\n        for component in self.components:\n            content += component.generate_netlist_bloc()        # use the class instances of componenets stroed in components to generate template and add it to content\n\n        with open(self.file_path, \"w\") as file1:\n            file1.write(content)\n</code></pre>"},{"location":"api/#src.net_generator.NetworkGenerator","title":"<code>NetworkGenerator</code>","text":"<p>The main class that generates all the netlist file, it is based on the Netlist class, It iterates over all the components by group of similar ones, it appends instances of  each component to the components list, while adding separation formatting between groups of similar components.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>[str]</code> <p>The path to the file where the netlist will be written.</p> <code>num_input</code> <code>[int]</code> <p>The number of input neurons in the network.</p> <code>num_output</code> <code>[int]</code> <p>The number of output neurons in the network.</p> <code>num_cells</code> <code>[int]</code> <p>The number of MTJ cells in each synapse.</p> <code>netlist</code> <code>[Netlist]</code> <p>The netlist object that will be written to a file.</p> <code>n_spik_vec</code> <code>[list of int]</code> <p>A list containing the number of spikes for each input neuron.</p>"},{"location":"api/#src.net_generator.NetworkGenerator--methods","title":"Methods","text":"<p>generate_netlist_file():     similar to the generate_netlist_file of the Netlist class, but instead of generating a single component,      it operates globally, ie: it generates the whole netlist by iterating through the method of Netlist class.</p> Source code in <code>src/net_generator.py</code> <pre><code>class NetworkGenerator:\n    \"\"\"\n    The main class that generates all the netlist file, it is based on the Netlist class,\n    It iterates over all the components by group of similar ones, it appends instances of \n    each component to the components list, while adding separation formatting between groups of similar components.\n\n    Attributes:\n        file_path [str]: The path to the file where the netlist will be written.\n        num_input [int]: The number of input neurons in the network.\n        num_output [int]: The number of output neurons in the network.\n        num_cells [int]: The number of MTJ cells in each synapse.\n        netlist [Netlist]: The netlist object that will be written to a file.\n        n_spik_vec [list of int]: A list containing the number of spikes for each input neuron.\n\n    Methods\n    -------\n    generate_netlist_file():\n        similar to the generate_netlist_file of the Netlist class, but instead of generating a single component, \n        it operates globally, ie: it generates the whole netlist by iterating through the method of Netlist class.\n    \"\"\"\n\n    def __init__(self, file_path, num_input, num_output, num_cells, n_spik_vec):\n        self.file_path = file_path\n        self.num_input = num_input\n        self.num_output = num_output\n        self.num_cells = num_cells\n        self.netlist = Netlist(file_path)\n        self.n_spik_vec = n_spik_vec # a list of a flattned array, containing n_spikes for each input neuron\n\n    def generate_netlist_file(self):\n        self.netlist.add_component(Synapse_subskt(self.num_cells))\n        self.netlist.add_component(Separator())\n\n        num_synapses = self.num_input * self.num_output\n\n        # add the synapses \n        for i in range(1, num_synapses + 1):\n            input_index = (i - 1) % self.num_input + 1\n            output_index = (i - 1) // self.num_input + 1\n            synapse = Synapse(input_index, output_index, self.num_cells)\n            self.netlist.add_component(synapse)\n\n        self.netlist.add_component(Separator())\n\n        # add input neurons\n        for i in range(1, self.num_input + 1):\n            input_neuron = Input_neuron(i, self.n_spik_vec[i-1])\n            self.netlist.add_component(input_neuron)\n\n        self.netlist.add_component(Separator())\n\n        # add output neurons \n        for i in range(1, self.num_output + 1):\n            output_neuron = Output_neuron(i)\n            self.netlist.add_component(output_neuron)\n\n        self.netlist.generate_netlist_file()\n</code></pre>"},{"location":"api/#src.net_generator.Output_neuron","title":"<code>Output_neuron</code>","text":"<p>A class to specify a netlist bloc of an output neuron of the SNN,  a method takes a template, adds information of the current neuron  (neuron index, membrane threshold). That sting bloc will then be included in the final netlist.</p> <p>Attributes:</p> Name Type Description <code>output_index</code> <code>[int]</code> <p>The index of this output neuron.</p>"},{"location":"api/#src.net_generator.Output_neuron--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that output neuron in the final netlist file.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Output_neuron:\n    \"\"\"\n    A class to specify a netlist bloc of an output neuron of the SNN, \n    a method takes a template, adds information of the current neuron \n    (neuron index, membrane threshold). That sting bloc will then be included\n    in the final netlist.\n\n    Attributes:\n        output_index [int]: The index of this output neuron.\n\n\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that output neuron in the final netlist file. \n    \"\"\"\n\n    def __init__(self, output_index):\n        self.output_index = output_index \n\n    def generate_netlist_bloc(self):\n        template = ( \"output_neuron{} (output{}) LIF_neuron mem_vth=mem_vth\\n\" )\n\n        return template.format(self.output_index, self.output_index)\n</code></pre>"},{"location":"api/#src.net_generator.Separator","title":"<code>Separator</code>","text":"<p>A class to seperate between componenets in the netlist for a better formatting.</p>"},{"location":"api/#src.net_generator.Separator--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a separation as a string.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Separator:\n    \"\"\"\n    A class to seperate between componenets in the netlist for a better formatting.\n\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a separation as a string.\n    \"\"\"\n\n    def generate_netlist_bloc(self):\n        return \"\\n//===================================================\\n\"     \n</code></pre>"},{"location":"api/#src.net_generator.Synapse","title":"<code>Synapse</code>","text":"<p>A class to specify a netlist bloc that describes an MTJ-based synapse of the SNN,  generate_netlist_bloc is a method that returns as string which represents a template  bloc of the synapse to be included in the netlist later. It personalizes the synapse at the current iteration by adding its specific informatio (connected neurons, number  of MTJs per synapse, initialized states, seeds,... ). The synapse template calls the  compound_synapse subcircuit which should be included once in the head of the netlist.</p> <p>Attributes:</p> Name Type Description <code>input_index</code> <code>[int]</code> <p>The index of the input neuron connected to this synapse.</p> <code>output_index</code> <code>[int]</code> <p>The index of the output neuron connected to this synapse.</p> <code>paps</code> <code>[list of int]</code> <p>The list of initial states of free layers for each MTJ in the synapse. (0 parallel, 1 anti-parallel).</p> <code>seeds</code> <code>[list of int]</code> <p>The list of seed values used for stochasticity for each MTJ in the synapse.</p>"},{"location":"api/#src.net_generator.Synapse--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to that synapse in the final netlist file.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Synapse:\n    \"\"\"\n    A class to specify a netlist bloc that describes an MTJ-based synapse of the SNN, \n    generate_netlist_bloc is a method that returns as string which represents a template \n    bloc of the synapse to be included in the netlist later. It personalizes the synapse\n    at the current iteration by adding its specific informatio (connected neurons, number \n    of MTJs per synapse, initialized states, seeds,... ). The synapse template calls the \n    compound_synapse subcircuit which should be included once in the head of the netlist.\n\n    Attributes:\n        input_index [int]: The index of the input neuron connected to this synapse.\n        output_index [int]: The index of the output neuron connected to this synapse.\n        paps [list of int]: The list of initial states of free layers for each MTJ in the synapse. (0 parallel, 1 anti-parallel).\n        seeds [list of int]: The list of seed values used for stochasticity for each MTJ in the synapse.\n\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to that synapse in the final netlist file. \n\n    \"\"\"\n\n    def __init__(self, input_index, output_index, num_cells):\n        self.input_index = input_index\n        self.output_index = output_index\n        self.seeds = [random.randint(0, 9999) for _ in range(num_cells)]\n        #self.paps = [i%2 for i in range(num_cells)]                 # alternate 0&amp;1 in the MTJs of the synapse\n        self.paps = [random.randint(0, 1) for _ in range(num_cells)] #initialize randamely\n\n    def generate_netlist_bloc(self):                 \n        template = \"synapse{}_{} (input{} output{}) compound_synapse \"\n        paps_str = \" \".join(\"PAP{}={}\".format(i + 1, pap) for i, pap in enumerate(self.paps))\n        seeds_str = \" \".join(\"seed{}={}\".format(i + 1, seed) for i, seed in enumerate(self.seeds))\n        return template.format(\n            self.input_index, self.output_index, self.input_index, self.output_index\n        ) + paps_str + \" \\\\\\n\\t\\t\" + seeds_str + \"\\n\"\n</code></pre>"},{"location":"api/#src.net_generator.Synapse_subskt","title":"<code>Synapse_subskt</code>","text":"<p>A class to specify a netlist bloc of the synapse subcircuit named compound_synapse,  which will be called by all the synapses. It is composed of multiple MTJs (the number is given as attribute),  and it makes call of the cellPMAMTJ subcircuit which is predefined in the initial netlist file. generate_netlist_bloc is a method that returns the subcircuit template to be included in the netlist. It takes an initial template, adds parameters to it : either to set stochasticity, variability, temperature and its variation or not, and sets as parameters the initial state of the MTJ, and the seed. </p> <p>Attributes:</p> Name Type Description <code>num_cells</code> <code>[int]</code> <p>The number of MTJ cells in each synapse.</p>"},{"location":"api/#src.net_generator.Synapse_subskt--methods","title":"Methods","text":"<p>generate_netlist_bloc():     Generates a string bloc specefic to the compound_synapse subcircuit in the final netlist file.</p> Source code in <code>src/net_generator.py</code> <pre><code>class Synapse_subskt:\n    \"\"\"\n    A class to specify a netlist bloc of the synapse subcircuit named compound_synapse, \n    which will be called by all the synapses. It is composed of multiple MTJs (the number is given as attribute), \n    and it makes call of the cellPMAMTJ subcircuit which is predefined in the initial netlist file.\n    generate_netlist_bloc is a method that returns the subcircuit template to be included in the netlist.\n    It takes an initial template, adds parameters to it : either to set stochasticity, variability,\n    temperature and its variation or not, and sets as parameters the initial state of the MTJ, and the seed. \n\n    Attributes:\n        num_cells [int]: The number of MTJ cells in each synapse.\n\n\n    Methods\n    -------\n    generate_netlist_bloc():\n        Generates a string bloc specefic to the compound_synapse subcircuit in the final netlist file. \n    \"\"\"\n\n    def __init__(self, num_cells):\n        self.num_cells = num_cells\n\n    def generate_netlist_bloc(self):\n        template = (\"subckt compound_synapse in_ter out_ter \\n\"\n                    \"parameters {} \\n\")\n\n        parameters = \" \".join([\"seed{}\".format(i+1) for i in range(self.num_cells)] +\n                              [\"PAP{}\".format(i+1) for i in range(self.num_cells)])\n\n        cells = \"\"\n        for i in range(self.num_cells): #Here we define synapse terminals in a way to let MTJs T2 terminal node same as synapse's input node\n            cell_line = (\"\\tcell{} (out_ter in_ter) cellPMAMTJ   param1=gl_STO   param2=gl_RV   param3=gl_T   param4=gl_Temp_var param7=RV_dev   \"\n                         \"param5=PAP{}   param6=seed{}\\n\".format(i+1, i+1, i+1))\n            cells += cell_line\n\n        netlist_bloc = template.format( parameters) + cells + \"ends compound_synapse\\n\"\n        return netlist_bloc\n</code></pre>"},{"location":"api/#3-substitution-run","title":"3. Substitution Run","text":"<p>This module provides utility functions for substituting values into templates and executing shell commands. It is designed to facilitate the automation of script generation and execution processes. The substitution method used here is inspired by the approach in the monaco project by @servinagrero: https://github.com/servinagrero/monaco/tree/develop</p> <p>Functions:</p> Name Description <code>substitute_templ</code> <p>Reads a template from a file, substitutes values from</p> <code>exec_cmd</code> <p>Executes a given shell command, optionally displaying the output.</p> <p>Example Usage: <pre><code>substitute_templ('input_template.txt', 'output_file.txt', {'key1': 'value1'}, {'key2': 'value2'})\nexec_cmd('ls -la', verbose=True)\n</code></pre></p>"},{"location":"api/#src.subst_run.exec_cmd","title":"<code>exec_cmd(command, *, verbose=False)</code>","text":"<p>Execute a given shell command using subprocess.run.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to execute.</p> required <code>verbose</code> <code>bool</code> <p>Whether to display the output of the command.</p> <code>False</code> Source code in <code>src/subst_run.py</code> <pre><code>def exec_cmd(command: str, *, verbose: bool = False) -&gt; None:\n    \"\"\"Execute a given shell command using subprocess.run.\n\n    Args:\n      command: Shell command to execute.\n      verbose: Whether to display the output of the command.\n    \"\"\"\n    run_args = {\n        'args': command,  # Corrected this line\n        'shell': True,\n        'check': True\n    }\n\n    if not verbose:\n        run_args['stdout'] = DEVNULL\n        run_args['stderr'] = DEVNULL\n\n    run(**run_args)\n</code></pre>"},{"location":"api/#src.subst_run.substitute_templ","title":"<code>substitute_templ(template_file, output_file, *substitution_dicts)</code>","text":"<p>Substitute values into a template read from a file.</p> <p>Parameters:</p> Name Type Description Default <code>template_file</code> <code>str</code> <p>Path to the input file containing the template.</p> required <code>output_file</code> <code>str</code> <p>Path to the output file to write the substituted content.</p> required <code>*substitution_dicts</code> <code>Dict[str, str]</code> <p>Dictionaries containing values to substitute into the template.</p> <code>()</code> Source code in <code>src/subst_run.py</code> <pre><code>def substitute_templ(template_file: str, output_file: str, *substitution_dicts: Dict[str, str]):\n    \"\"\"Substitute values into a template read from a file.\n\n    Args:\n      template_file: Path to the input file containing the template.\n      output_file: Path to the output file to write the substituted content.\n      *substitution_dicts: Dictionaries containing values to substitute into the template.\n    \"\"\"\n    with open(template_file, 'r') as tmpl_file:\n        tmpl = Template(tmpl_file.read())\n        substitutions = {k: v for d in substitution_dicts for k, v in d.items()}\n        substituted_content = tmpl.safe_substitute(substitutions)\n\n        with open(output_file, 'w+') as result_file:\n            result_file.write(substituted_content)\n</code></pre>"},{"location":"api/#4-plot-euclidean-distance","title":"4. Plot Euclidean Distance","text":"<p>This module calculates and plots the Euclidean distance between the final weights of trained SNNs  and the input images. The module provides functions to compute the distances for individual letters as well as average  distances across multiple letters.</p> <p>Functions:</p> Name Description <code>eucl_dist</code> <p>Calculate and plot Euclidean distances for a specific letter.</p> <code>avg_eucl_dist</code> <p>Calculate and plot average Euclidean distances across multiple letters.</p> <code>calculate_dist</code> <p>Helper function to calculate Euclidean distances for a given letter.</p> <code>plot_distances</code> <p>Helper function to plot the Euclidean distances.</p> <p>Example Usage: <pre><code>eucl_dist(trained_letters_dict, 'I')\navg_eucl_dist(trained_letters_dict)\n</code></pre></p>"},{"location":"api/#src.plot_eucl_dist.avg_eucl_dist","title":"<code>avg_eucl_dist(trained_letters_dict)</code>","text":"<p>Calculate and plot average Euclidean distances across multiple letters.</p> <p>Parameters:</p> Name Type Description Default <code>trained_letters_dict</code> <code>dict</code> <p>Dictionary containing base directories for trained letters.</p> required Source code in <code>src/plot_eucl_dist.py</code> <pre><code>def avg_eucl_dist(trained_letters_dict):\n    \"\"\"\n    Calculate and plot average Euclidean distances across multiple letters.\n\n    Args:\n        trained_letters_dict (dict): Dictionary containing base directories for trained letters.\n    \"\"\"\n    # Load the all_images dictionary from the pickle file\n    all_images = \"input_images/letter_imgs/all_images.pkl\"\n    with open(all_images, 'rb') as pickle_file:\n        images = pickle.load(pickle_file)\n\n    # Initialize a structure to hold the distances\n    average_distances = {nc: {dev: [] for dev in VR_std} for nc in mtjs}\n\n    for letter, base_dir in trained_letters_dict.items():\n        specific_letter_image = images[letter]\n        euclidean_distances = calculate_dist(base_dir, specific_letter_image)\n\n        # Accumulate the distances for averaging\n        for num_cells in mtjs:\n            for dev in VR_std:\n                average_distances[num_cells][dev] += euclidean_distances[num_cells][dev]\n\n    # Average the distances across letters\n    for num_cells in mtjs:\n        for dev in VR_std:\n            if average_distances[num_cells][dev]:\n                average_distances[num_cells][dev] = np.mean(average_distances[num_cells][dev])\n            else:\n                average_distances[num_cells][dev] = None\n\n    plot_distances(average_distances, 'Average Euclidean Distance vs VR_std Across Letters')\n</code></pre>"},{"location":"api/#src.plot_eucl_dist.calculate_dist","title":"<code>calculate_dist(base_dir, letter_image)</code>","text":"<p>Helper function to calculate Euclidean distances for a given letter.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>str</code> <p>Base directory containing the trained folders.</p> required <code>letter_image</code> <code>ndarray</code> <p>The image of the specific letter.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing Euclidean distances for each combination of num_cells and VR_std.</p> Source code in <code>src/plot_eucl_dist.py</code> <pre><code>def calculate_dist(base_dir, letter_image):\n    \"\"\"\n    Helper function to calculate Euclidean distances for a given letter.\n\n    Args:\n        base_dir (str): Base directory containing the trained folders.\n        letter_image (numpy.ndarray): The image of the specific letter.\n\n    Returns:\n        dict: Dictionary containing Euclidean distances for each combination of num_cells and VR_std.\n    \"\"\"\n    trained_folders = sorted(glob.glob(base_dir))\n    euclidean_distances = {nc: {dev: [] for dev in VR_std} for nc in mtjs}\n\n    for trained_folder in trained_folders:\n        folder_name = os.path.basename(trained_folder)\n        parts = folder_name.split('_')\n        dev = float(parts[-2].replace('dev', ''))\n        num_cells = int(parts[-1].replace('cells', ''))\n\n        data_file = os.path.join(trained_folder, \"results.txt\")\n        if os.path.exists(data_file):\n            data = np.genfromtxt(data_file, delimiter=\"\", skip_header=4)\n            final_weights_flat = data[-1, 1:-1]\n            euclidean_distance = np.linalg.norm(final_weights_flat/num_cells - (letter_image/255.0))\n            euclidean_distances[num_cells][dev].append(euclidean_distance)\n\n    return euclidean_distances\n</code></pre>"},{"location":"api/#src.plot_eucl_dist.eucl_dist","title":"<code>eucl_dist(trained_letters_dict, specific_letter)</code>","text":"<p>Calculate and plot Euclidean distances for a specific letter.</p> <p>Parameters:</p> Name Type Description Default <code>trained_letters_dict</code> <code>dict</code> <p>Dictionary containing base directories for trained letters.</p> required <code>specific_letter</code> <code>str</code> <p>The letter to calculate distances for.</p> required Source code in <code>src/plot_eucl_dist.py</code> <pre><code>def eucl_dist(trained_letters_dict, specific_letter):\n    \"\"\"\n    Calculate and plot Euclidean distances for a specific letter.\n\n    Args:\n        trained_letters_dict (dict): Dictionary containing base directories for trained letters.\n        specific_letter (str): The letter to calculate distances for.\n    \"\"\"\n    # Load the all_images dictionary from the pickle file\n    all_images = \"input_images/letter_imgs/all_images.pkl\"\n    with open(all_images, 'rb') as pickle_file:\n        images = pickle.load(pickle_file)\n\n    specific_letter_image = images[specific_letter]\n    base_dir = trained_letters_dict.get(specific_letter)\n\n    if base_dir:\n        euclidean_distances = calculate_dist(base_dir, specific_letter_image)\n        plot_distances(euclidean_distances, f'Euclidean Distance vs VR_std for Letter \"{specific_letter}\"')\n    else:\n        print(f\"Base directory for letter '{specific_letter}' not found in the provided dictionary.\")\n</code></pre>"},{"location":"api/#src.plot_eucl_dist.plot_distances","title":"<code>plot_distances(euclidean_distances, title)</code>","text":"<p>Helper function to plot the Euclidean distances.</p> <p>Parameters:</p> Name Type Description Default <code>euclidean_distances</code> <code>dict</code> <p>Dictionary containing Euclidean distances to plot.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required Source code in <code>src/plot_eucl_dist.py</code> <pre><code>def plot_distances(euclidean_distances, title):\n    \"\"\"\n    Helper function to plot the Euclidean distances.\n\n    Args:\n        euclidean_distances (dict): Dictionary containing Euclidean distances to plot.\n        title (str): Title of the plot.\n    \"\"\"\n    fig, axe1 = plt.subplots()\n    for num_cells, dev_distances in euclidean_distances.items():\n        devs = sorted(dev_distances.keys())\n        distances = [np.mean(dev_distances[dev]) for dev in devs]\n        axe1.plot(devs, distances, label=f'num_cells={num_cells}', marker='o')\n\n    axe1.set_xlabel('VR_std')\n    axe1.set_ylabel('Euclidean Distance')\n    axe1.set_title(title)\n    axe1.legend()\n</code></pre>"},{"location":"api/#5-plot-weight-membrane","title":"5. Plot Weight Membrane","text":"<p>This script processes and plots simulation results for an SNN. It loads data from a specified results file, plots the weights history, the output  neuron membrane potential, and compares initial and final weights.</p> <p>Functions:</p> Name Description <code>parse_arguments</code> <p>Parse command-line arguments.</p> <code>load_data</code> <p>from results.txt, organized as :  time | synapse1 | synapse2 | ... | membrane_out_neuron.</p> <code>plot_weights_history</code> <p>Plot the weights history.</p> <code>plot_membrane_potential</code> <p>Plot the output neuron membrane potential.</p> <code>plot_weights_comparison</code> <p>Plot initial and final weights comparison.</p> <code>main</code> <p>Main function to orchestrate loading data and plotting results.</p> <p>Example Usage: <pre><code>&gt;&gt; python plot_weig_membr.py simulations_folder_name\n</code></pre></p>"},{"location":"api/#src.plot_weig_membr.load_data","title":"<code>load_data(folder_name)</code>","text":"<p>Load data from the results file.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def load_data(folder_name):\n    \"\"\"Load data from the results file.\"\"\"\n    file_path = os.path.join(folder_name, \"results.txt\")\n    if not os.path.isfile(file_path):\n        print(f\"Error: File {file_path} does not exist.\")\n        sys.exit(1)\n    return np.genfromtxt(file_path, delimiter=\"\", skip_header=4)\n</code></pre>"},{"location":"api/#src.plot_weig_membr.main","title":"<code>main()</code>","text":"<p>Main function to orchestrate loading data and plotting results.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def main():\n    \"\"\"Main function to orchestrate loading data and plotting results.\"\"\"\n    args = parse_arguments()\n    data = load_data(args.folder_name)\n\n    init_weights_flat = data[0, 1:-1]\n    init_weights_img = init_weights_flat.reshape((5, 5))\n\n    final_weights_flat = data[-1, 1:-1]\n    final_weights_img = final_weights_flat.reshape((5, 5))\n\n    # Update matplotlib global parameters for font\n    plt.rcParams.update({'font.size': 14, 'font.family': 'serif'})\n\n    plot_weights_history(data)\n    plot_membrane_potential(data)\n    fig = plot_weights_comparison(init_weights_img, final_weights_img)\n\n    # Save figure to home directory if needed\n    # plt.savefig(os.path.join(os.path.expanduser(\"~\"), os.path.basename(args.folder_name) + \".pdf\"), format='pdf')\n\n    plt.show()\n</code></pre>"},{"location":"api/#src.plot_weig_membr.parse_arguments","title":"<code>parse_arguments()</code>","text":"<p>Parse command-line arguments.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def parse_arguments():\n    \"\"\"Parse command-line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Plot simulation results.\")\n    parser.add_argument(\"folder_name\", help=\"Folder containing the simulation results.\")\n    return parser.parse_args()\n</code></pre>"},{"location":"api/#src.plot_weig_membr.plot_membrane_potential","title":"<code>plot_membrane_potential(data)</code>","text":"<p>Plot the output neuron membrane potential.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def plot_membrane_potential(data):\n    \"\"\"Plot the output neuron membrane potential.\"\"\"\n    plt.figure(figsize=(5, 5))\n    plt.plot(1e3 * data[:, 0], 1e3 * data[:, -1], color=\"green\")\n    plt.title(\"Output neuron membrane potential\")\n    plt.xlabel(\"Time (ms)\")\n    plt.ylabel(\"Mem potential (mV)\")\n    plt.grid(True)\n</code></pre>"},{"location":"api/#src.plot_weig_membr.plot_weights_comparison","title":"<code>plot_weights_comparison(init_weights_img, final_weights_img)</code>","text":"<p>Plot initial and final weights comparison.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def plot_weights_comparison(init_weights_img, final_weights_img):\n    \"\"\"Plot initial and final weights comparison.\"\"\"\n    fig, (axe1, axe2) = plt.subplots(1, 2, figsize=(8, 4))\n\n    im1 = axe1.imshow(init_weights_img, cmap='gray')\n    axe1.set_title(\"Initial Weights\")\n    axe1.axis('off')\n    cbar1 = plt.colorbar(im1, ax=axe1)\n    cbar1.locator = MaxNLocator(integer=True)\n    cbar1.update_ticks()\n\n    im2 = axe2.imshow(final_weights_img, cmap='gray')\n    axe2.set_title(\"Trained Weights\")\n    axe2.axis('off')\n    cbar2 = plt.colorbar(im2, ax=axe2)\n    cbar2.locator = MaxNLocator(integer=True)\n    cbar2.update_ticks()\n\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/#src.plot_weig_membr.plot_weights_history","title":"<code>plot_weights_history(data)</code>","text":"<p>Plot the weights history.</p> Source code in <code>src/plot_weig_membr.py</code> <pre><code>def plot_weights_history(data):\n    \"\"\"Plot the weights history.\"\"\"\n    plt.figure(figsize=(5, 5))\n    plt.plot(1e3 * data[:, 0], data[:, 1:-1])\n    plt.title(\"Weights history\")\n    plt.xlabel(\"Time (ms)\")\n    plt.ylabel(\"Weight state\")\n    plt.grid(True)\n</code></pre>"},{"location":"api/#6-generate-letters","title":"6. Generate Letters","text":"<p>This script generates binary images of letters, saves them in both .npy and .pkl formats,  and stores them in a specified directory. Each letter is represented by specific pixel  positions in a 5x5 image grid. Images are saved individually as .npy arrays,  and collectively as .pkl dict. all images are generated at once.</p>"},{"location":"api/#src.input_images.gen_letters.create_letter_image","title":"<code>create_letter_image(letter, positions)</code>","text":"<p>Create and save an image of a specified letter.</p> <p>Parameters:</p> Name Type Description Default <code>letter</code> <code>str</code> <p>The letter to create an image for.</p> required <code>positions</code> <code>list of tuples</code> <p>The pixel positions of the letter in the image.</p> required Source code in <code>src/input_images/gen_letters.py</code> <pre><code>def create_letter_image(letter, positions):\n    \"\"\"\n    Create and save an image of a specified letter.\n\n    Args:\n        letter (str): The letter to create an image for.\n        positions (list of tuples): The pixel positions of the letter in the image.\n    \"\"\"\n    image = np.full((image_size[0], image_size[1]), background_color, dtype=np.uint8)\n\n    for x, y in positions:\n        image[y, x] = letter_color\n        letter_pixel_values[letter] = image.flatten()\n\n    # Save the image\n    # plt.imsave(f'{save_dir}/generated_{letter}.png', image, format=\"png\") # PNG \n    np.save(f'{save_dir}/generated_{letter}.npy', image)                  # npy\n</code></pre>"},{"location":"api/#7-view-images","title":"7. View Images","text":"<p>This script loads and displays an image stored in a .npy file. It uses matplotlib  to visualize the image and print its size and shape.</p>"},{"location":"api/#src.input_images.see_img.load_and_display_image","title":"<code>load_and_display_image(input_path)</code>","text":"<p>Load an image from a .npy file and display it using matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the .npy file containing the image.</p> required Source code in <code>src/input_images/see_img.py</code> <pre><code>def load_and_display_image(input_path):\n    \"\"\"\n    Load an image from a .npy file and display it using matplotlib.\n\n    Args:\n        input_path (str): Path to the .npy file containing the image.\n    \"\"\"\n    image = np.load(input_path)\n    print(f\"size is: {np.size(image)} and shape is {np.shape(image)} \")\n\n    plt.imshow(image, cmap='gray')\n    plt.colorbar()\n    plt.show()\n</code></pre>"},{"location":"api/#8-extract-from-mnist","title":"8. Extract from MNIST","text":"<p>This script extracts specific images from the MNIST dataset and saves them as .npy files. The script loads MNIST images from the idx3-ubyte format and saves selected images in a specified directory.</p> <p>Functions:</p> Name Description <code>load_idx3_ubyte</code> <p>Loads MNIST images from a given idx3-ubyte file.</p>"},{"location":"api/#src.input_images.extract_mnist.load_idx3_ubyte","title":"<code>load_idx3_ubyte(idx3_ubyte_file)</code>","text":"<p>Load MNIST data from the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>idx3_ubyte_file</code> <code>str</code> <p>Path to the idx3-ubyte file containing MNIST images.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Array of shape (num_images, rows, cols) containing the MNIST images.</p> Source code in <code>src/input_images/extract_mnist.py</code> <pre><code>def load_idx3_ubyte(idx3_ubyte_file):\n    \"\"\"\n    Load MNIST data from the given file path.\n\n    Args:\n        idx3_ubyte_file (str): Path to the idx3-ubyte file containing MNIST images.\n\n    Returns:\n        np.ndarray: Array of shape (num_images, rows, cols) containing the MNIST images.\n    \"\"\"\n    with open(idx3_ubyte_file, 'rb') as f:\n        magic, num_images, rows, cols = np.frombuffer(f.read(16), dtype=np.dtype('&gt;i4'))\n        assert magic == 2051, 'Invalid magic number'\n        images = np.frombuffer(f.read(), dtype=np.uint8).reshape(num_images, rows, cols)\n    return images\n</code></pre>"},{"location":"in_neuron/","title":"Input Neuron","text":"Verilog-A model of input neuron <pre><code>`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule Input_neuron(terminal1, terminal2);\n  inout terminal1, terminal2; \n  electrical terminal1, terminal2;\n  voltage V_neuron;\n  parameter real r=0 from [0:inf);\n\n  parameter real n_spikes = 2 ;             // It represents the neuron intensity\n  parameter real spike_duration = 60e-3 ;   // Maximum duration of a single spike\n  parameter real presenting_time = 300e-3;  // The total time a pixel is presented to the network\n  real slope = -(150-(-90))*1e-3/spike_duration; // slpe of input spike\n  real t_window = presenting_time/n_spikes; // window includes presentime_time + itme between two spikes \n  real t_;\n  real t0, spiking;\n\n  analog begin\n\n    if (analysis(\"ic\")) begin     // initial conditions\n      V(V_neuron) &lt;+ 0;\n      t_ = 0;\n      spiking = 0;\n\n    end else begin                // Analysis begin\n      if (spiking == 0) begin     // start spiking \n        t0 = $abstime;\n        spiking = 1; \n        V(V_neuron) &lt;+ 150e-3;\n      end else begin              // it is already spiking\n        t_ = $abstime - t0;\n\n        if (t_ &lt;= t_window &amp;&amp; t_ &lt;= spike_duration) begin\n          V(V_neuron) &lt;+ slope*t_+150e-3; \n        end else if (t_ &gt; spike_duration &amp;&amp; t_ &lt;= t_window) begin\n          V(V_neuron) &lt;+ 0;\n        end else begin\n          spiking = 0;\n          t_ = 0;\n          V(V_neuron) &lt;+ 150e-3;\n        end\n      end                       // End spiking \n    end // End of the analysis\n    V( terminal1, terminal2) &lt;+ r*I( terminal1, terminal2)+ V(V_neuron);\n\n   end // End of the analog\nendmodule // End of the module\n</code></pre>"},{"location":"mtj_model/","title":"MTJ","text":"Verilog-A model of MTJ device <pre><code>/* Copyright @ 2018 Fert Beijing Institute, BDBC and School of Electronic and Information Engineering, Beihang Univeristy, Beijing 100191, China\nThe terms under which the software and associated documentation (the Software) is provided are as the following:\nThe Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\nThe authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n3. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\nAgreed to by \nYou WANG, Yue Zhang, Weisheng Zhao, Lirida Alves de Barros Naviner, Hao Cai and Jaques-Olivier Klein\n\n//Title: Compact model of Perpendicular Magnetic Anistropy (PMA) MTJ based on Spin transfer torque mechanism\n//Version: Beta.4.5\n//Date:20 April 2020\n//Language: VerilogA\n\n-------------------------------------------\nIn this model, it takes into account the static, dynamic and stochastic behavoirs of PMA MTJ nanopillar\n1.MTJ resistance calculation based on brinkman model\n2.TMR dependence on the bias voltage\n3.Spin polarity calculation model for magnetic tunnel junction\n4.Critical current calculation \n5.Dynamic model (&gt;critical current, also sun's model)\n6.Stochastic model \n7.Resistance variation\n8.Temperature evaluation\n-------------\nModified by Salah DADDINOUNOU\n// Optimized the code and removed redundancy.\n// Signal ix is set to 0 or 1 not 0 or -1 (it was set negative to indecate that the current flows out, when there were a probing termnial)\n// Removed the probing terminals because the framework allows direct access to signals. Removed also temp terminal.   \n*/\n/*--------------------The parameters are from the prototypes of Univ. Tohuku-------------------*/\n\n`resetall\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`define explimit 85.0\n`define exp(x) exp(min(max((x),-`explimit),`explimit))\n`define sqrt(x) pow( (x), 0.5)\n\n`define rec 1           //Shape definition\n`define ellip 2\n`define circle 3\n\n/*----------------------------Electrical Constants-----------------------------*/ \n/*----------Elementary Charge---------------*/\n`define e 1.6e-19\n/*----------Bohr Magnetron Costant----------*/\n`define ub 9.27e-28\n/*----------Boltzmann Constant------------- */ \n`define Kb 1.38e-23\n/*----------Electron Mass------------- */ \n`define m 9.10e-31\n/*----------Euler's constant---------------*/ \n`define C 0.577\n\n\nmodule Model(T1,T2);\ninout T1, T2;\nelectrical T1, T2;\nelectrical n1,n2; //virtual terminals of RC circuit for temperature evaluation \n/*----------Ttrans=store the state of the MTJ with time influence, non-volatile way------------- */\n\n/*--------------------MTJ Technology Parameters(Corresponds to the HITACHI MTJ Process)-------------*/ \n\n/*----------Gilbert Damping Coefficient---------------*/\nparameter real alpha=0.027;\n/*----------GyroMagnetic Constant in Hz/Oe---------------*/\nparameter real gamma=1.76e7;\n/*----------Electron Polarization Percentage % ---------------*/ \nparameter real P=0.52;\n/*----------Out of plane Magnetic Anisotropy in Oersteds---------------*/ \nparameter real Hk=1433;\n/*----------Saturation Field in the Free Layer in Oersteds---------------*/\nparameter real Ms=15800;\n/*----------The Energy Barrier Height for MgO in electron-volt---------------*/ \nparameter real PhiBas=0.4;\n/*----------Voltage bias when the TMR(real) is 1/2TMR(0) in Volt---------------*/ \nparameter real Vh=0.5; //experimental value with MgO barrier\n\n/*--------------Device Parameters(Corresponds to the HITACHI 240 x 80 MTJ)--------------------------*/ \n\n/*----------Height of the Free Layer in nm---------------*/\nparameter real tsl=1.3e-9 from[0.7e-9:3.0e-9];\n/*----------Length in nm---------------*/\nparameter real a=32e-9;\n/*----------Width in nm---------------*/\nparameter real b=32e-9;\n/*----------Radius in nm---------------*/\nparameter real r=16e-9;\n/*----------Height of the Oxide Barrier in nm---------------*/ \nparameter real tox=8.5e-10 from[8e-10:15e-10]; \n/*----------TMR(0) with Zero Volt Bias Voltage ---------------*/ \nparameter real TMR=0.7;\n\n/*----------Shape of MTJ---------------*/\nparameter real SHAPE=3 from[1:3];    // 1:rectangle  2:ellipse 3:circle\n/*----------Neel-Brown model parameter ---------------*/\nparameter real tau0=8.7e-10; //experiental value, prototype Hitachi 2007m with CoFe layer \n/*----------Error probability Ps=1-Pr(t) ----------------*/\nparameter real Ps=0.999999;\n/*----------Threshold for Neel-Brown model----------------*/\nparameter real brown_threshold_AP2P=0.15;   \nparameter real brown_threshold_P2AP=0.1;   \n\n/*----------MTJ State Parameters----------------*/\n/*----------Initial state of the MTJ, 0 = parallele, 1 = anti-parallele----*/ \nparameter integer PAP=1 from[0:1]; \n/*----------Room temperature in Kelvin----------------*/\nparameter real T= 300;\n/*----------Resistance area product in ohmum2----------------*/ \nparameter real RA=5 from[5:15];\n\n/*----------Parameters of RC circuit for time modelisation for temperature---------------*/\nparameter integer Temp_var=0 from[0:1]; //choice of temperature fluctuation\n/*----------Heat capacity per unit volume in J/m3*K----------------*/\nparameter real Cv= 2.74e6 from[2.735e6:2.7805e6];\n/*----------Thermal conductivity of the thermal barrier(MgO) in W/m*K----------------*/ \nparameter real lam= 84.897 from [84.8912:84.9449];\n/*----------Total thickness of MTJ nanopillar in nm----------------*/\nparameter real thick_s= 3.355e-8;\n\n/*----------RC circuit for time modelisation for temperature---------------*/ \nparameter real resistor=100e6;\nparameter real coeff_tau=12;    //Coefficient to increase tau_th\nreal capacitor;                 //virtual capacitor\nreal tau_th;                    //characteristic heating/cooling time\nreal temp;                      //real temperature of MTJ\nreal temp_init;                 //temperature initialised\nreal R;                         //resistance of MTJ\n\n/*---------Parameters for stochasticity and variability behaviors---------------*/\nparameter integer STO=0 from[0:2];          // stochasticity: 0=no stochastic, 1=random exponential distribution, 2=random gauss distribution\nparameter integer RV=0 from[0:2];           // process varibility: 0 no var, 1 random uniform distribution,2 random gauss distribution\nparameter real dev = 0;                     // intermediate std parameter to be used bellow\nparameter real DEV_tox=dev; //0.03;         // variability std for gauss distribution(RV=2) of tox (oxide thickness) \nparameter real DEV_tsl=dev; //0.03;         // variability std for gauss distribution(RV=2) of tsl (FL thickness)\nparameter real DEV_TMR=dev; //0.03;         // variability std for gauss distribution(RV=2) of TMR \nparameter real STO_dev=1;                   // stochasticity std for gauss distribution(STO=2) of duration      \n\n/*------------------------------------variables-------------------------------------*/\n\n//Polaristion constant for the two states of STT-MTJ\nreal PolaP;         //Polarization state parallel of STT-MTJ\nreal PolaAP;        //Polarization state anti-parallel of STT-MTJ\nreal surface;       //Surface of MTJ\nreal gp;            //Critical current density for P state \nreal gap;           //Critical current density for AP state\nreal Em,EE;         //Variable of the Slonczewski model\nreal TMRR;          //TMR real value for P state\nreal TMRRT;         //TMR real value for AP state\nreal Ro;            //Resistance of MTJ when bias voltage = 0V \nreal Rap;           //Resistance value for AP state \nreal Rp;            //Resistance value for P state\n\n//Voltage of MTJ\nreal Vb;            //V(T1,T2) = V(T1) - V(T2)  When positive, it can switch P2AP \nreal Vc;            //V(T2,T1) = V(T2) - V(T1)  When positive, it can switch AP2P \nreal Id;            //Current of MTJ\n\n//critial current for the two states of STT-MTJ\nreal IcAP;          //Critial current for AP state\nreal IcP;           //Critial current for P state\nreal ix;            //Current used to store the state of the MTJ (0: parallel, 1: anti-parllel) \nreal tau;           //Probability parameter\nreal FA;            //Factor for calculating the resistance based on RA\n\n/*--------Stochastic effects--------------*/\n\nreal durationstatic, duration;      //time needed to be sure that the switching is effected\nreal toxreal;                       //real thickness of oxide layer     \nreal tslreal;                       //real thickness of free layer      \nreal TMRreal;                       //real TMR\n\nparameter integer mtj_seed = 0;     // device-specific seed generated by python to be used for both variability and stochasti \ninteger seed1=0;                    // seed for process variability random distributions \ninteger seed2=0;                    // seed for stochasticity random distributions  \n\n/*----------switching delay----------------*/\nreal P_APt;\nreal AP_Pt;\nreal NP_APt,NAP_Pt;\n\ninteger counter;\ninteger fp;\n//--------------------------------------------------------------------------------------------------------------------------------------//\n\nanalog begin\n\nif (SHAPE==1)               //square\nbegin\n    surface=a*b;\nend\nelse if (SHAPE==2)          //ellipse (a/2 and b/2 are semi-minor &amp; semi-major)\nbegin\n    surface=`M_PI*a*b/4;\nend\nelse                        // round\nbegin\n    surface=`M_PI*r*r;      \nend\n\nVc=V(T2,T1);\nVb=V(T1,T2);\n\n@(initial_step) begin\n    counter=0;\n    FA=3322.53/RA;              // initialization of resistance factor according to RA product\n    seed1 = mtj_seed;           // process variability MC\n    seed2 = mtj_seed;           // stochasticity MC\n\n    if (RV==1)                      //real thinkness of oxide layer, free layer and real TMR with uniform dist variability\n    begin\n        toxreal=$rdist_uniform(seed1,(tox-tox*DEV_tox),(tox+tox*DEV_tox));\n        tslreal=$rdist_uniform(seed1,(tsl-tsl*DEV_tsl),(tsl+tsl*DEV_tsl));\n        TMRreal=$rdist_uniform(seed1,(TMR-TMR*DEV_TMR),(TMR+TMR*DEV_TMR));          \n    end\n    else if (RV==2)                 //real thinkness of oxide layer, free layer and real TMR with gauss dist variability \n    begin\n        toxreal=abs($rdist_normal(seed1,tox,tox*DEV_tox));\n        tslreal=abs($rdist_normal(seed1,tsl,tsl*DEV_tsl));\n        TMRreal=abs($rdist_normal(seed1,TMR,TMR*DEV_TMR));                                      \n    end\n    else\n    begin                           // No variability \n        toxreal=tox;\n        tslreal=tsl;\n        TMRreal=TMR;\n    end\n    // parameters for temperature\n    temp=T;\n    temp_init=T;    \n    tau_th= Cv*thick_s / (lam/thick_s); \n    capacitor=coeff_tau*tau_th/resistor;\n\n    Ro=(toxreal*1.0e10/(FA*`sqrt(PhiBas)*surface*1.0e12))*exp(1.025*toxreal*1.0e10*`sqrt(PhiBas));      // Ro : Resistance of MTJ when bias voltage = 0V\n    //parameters for calculating switching delay\n    Em=Ms*tslreal*surface*Hk/2;      // Em : Variable of the Slonczewski model\n    duration=0.0;\n    P_APt=1e9;\n    AP_Pt=1e9;\n    NP_APt=1e9;\n    NAP_Pt=1e9;\n\n    if(analysis(\"dc\"))  //States inititialisation\n    begin\n        ix=PAP;         // ix: Current used to store the state of the MTJ    \n    end\n    else\n    begin\n        ix=PAP;\n    end \nend                     //end of initial_step\n\nif(Temp_var==0)         //temperature is constant\nbegin\n    temp=temp_init; \nend\nelse                    //temperature actualisation\nbegin\n    temp=V(n2) + temp_init;\nend      \nEE=Em/(`Kb*temp*40*`M_PI);  \n\n/*----calculation of real current------*/\n\nTMRR=TMRreal/(1+Vb*Vb/(Vh*Vh)); \nRp=Ro;\nRap=Rp*(1+TMRR);\nif(ix==0)\nbegin\n    R=Rp;\nend\nelse    //ie: ix=1 if dc and ix =-1 for tran\nbegin\n    R=Rap;\nend\n\nId=Vb/R;\n\n/*----calculation of rcritical current------*/\n\nPolaP=`sqrt(TMRreal*(TMRreal+2))/(2*(TMRreal+1));           //Polarization state parallel\ngp=alpha*gamma*`e*Ms*tslreal*Hk/(40*`M_PI*(`ub*PolaP));     //Critical current density    \nIcP=gp*surface;                                             // Critical current for P state\nPolaAP=`sqrt(TMRreal*(TMRreal+2))/(2*(TMRreal+1));          //Polarization state anti-parallel  \ngap=alpha*gamma*`e*Ms*tslreal*Hk/(40*`M_PI*(`ub*PolaAP));   //Critical current density  \nIcAP=gap*surface;                                           // Critical current for AP state         \n\n/*------Counter of time when real current is higher than critical current */\n\n@(above(Id-IcP,+1))   \nbegin\n    P_APt = $abstime;\n    NP_APt=1e9;     \nend\n\n@(above(-Id-IcAP,+1))\nbegin\n    AP_Pt = $abstime;\n    NAP_Pt=1e9;     \nend\n\n@(above(Vb-brown_threshold_P2AP,+1))\nbegin\n    NP_APt = $abstime;\n    AP_Pt=1e9;\n    NAP_Pt=1e9; \nend\n\n@(above(Vc-brown_threshold_AP2P,+1))\nbegin\n    NAP_Pt = $abstime;\n    P_APt=1e9;\n    NP_APt=1e9;     \nend\n//-------------------\nif(analysis(\"dc\"))                   // dc analysis                 \nbegin   \n    if(ix==0)\n    begin\n        if(Vb&gt;=(IcP*Rp))        \n        begin\n            ix=1.0;\n        end\n    end\n    else    //(ix==1)\n    begin               \n        if(Vc&gt;=(IcAP*Rap))\n        begin\n            ix=0.0;\n        end\n    end\n    I(T1,T2)&lt;+Id;                       //Actualisation of the current of MTJ with the value calculated\nend             \n//------------------------------------------------------------------------------------------------------------------------------\nelse                                    // transient analysis                 \nbegin\n    if(ix==0)                       // parallel state\n    begin   \n\n        if(Vb&gt;=IcP*Rp)              //Current higher than critical current, dynamic behavior: Sun model \n        begin\n            durationstatic=(`C+ln(`M_PI*`M_PI*(Em/(`Kb*temp*40*`M_PI))/4))*`e*1000*Ms*surface*tslreal*(1+P*P)/(4*`M_PI*2*`ub*P*10000*abs(Id-IcP));  //Average time needed for switching\n            if(STO==1)              //parallel -- Vb &gt; Icp *Rp -- expon_ stochast\n            begin\n                duration=abs($rdist_exponential(seed2, durationstatic)); \n            end\n            else if(STO==2)         //parallel -- Vb &gt; Icp *Rp -- normal_ stochast\n            begin                     \n                duration=abs($rdist_normal(seed2,durationstatic,durationstatic*STO_dev));\n            end \n            else                    //parallel -- Vb &gt; Icp *Rp -- NO stochast\n            begin           \n                duration=durationstatic;\n            end                         \n\n            if(duration&lt;=($abstime-P_APt))  // duration is enough to switch  //Switching of the free layer always occurs\n            begin\n                ix=1.0;      // change of the current state of MTJ  \n            end\n            else\n            begin\n                ix=0.0;\n            end\n        end\n        else                        // current smaller than critical current : Neel-Brown model\n\n        if(Vb&gt;brown_threshold_P2AP) //added\n        begin\n            ix=0.0;\n            tau=tau0*exp(Em*(1-abs(Id/IcP))/(`Kb*temp*40*`M_PI));   \n            if(Vb&gt;brown_threshold_P2AP) \n            begin\n                if (Vb&lt;0.8*IcP*Rp)\n                begin\n                    if(STO==1) \n                    begin\n                        duration=abs($rdist_exponential(seed2, tau));\n                    end\n                    else if(STO==2)\n                    begin\n                        duration=abs($rdist_normal(seed2,tau,tau*STO_dev));\n                    end     \n                    else\n                    begin\n                        duration=tau;           \n                    end                                     \n                    if (($abstime-NP_APt) &gt;= duration)  \n                    begin\n                        ix=1.0;  \n                    end\n                    else\n                    begin\n                        ix=0.0;\n                    end\n                end             \n            end     \n        end\n\n    end         // end of parallel state\n    //-----------------------------------------------------------------------------     \n    else       // initial state anti-parallel\n    begin\n\n        if(Vc&gt;=(IcAP*Rap)) // anti-parallel, current higher than critical current: Sun model\n        begin\n            durationstatic=(`C+ln(`M_PI*`M_PI*(Em/(`Kb*temp*40*`M_PI))/4))*`e*1000*Ms*surface*tslreal*(1+P*P)/(4*`M_PI*2*`ub*P*10000*abs(-Id-IcAP));\n            if(STO==1)\n            begin\n                duration=abs($rdist_exponential(seed2, durationstatic));\n            end\n            else if(STO==2)\n            begin\n                duration=abs($rdist_normal(seed2,durationstatic,durationstatic*STO_dev));       \n            end\n            else\n            begin\n                duration=durationstatic;\n            end\n            if(duration&lt;=($abstime-AP_Pt))\n            begin\n                ix=0.0;     \n            end \n            else        // duration is not enough to switch\n            begin\n                ix=1.0;\n            end\n\n        end         \n        else            // trans - stochastic - anti-parallel - Neel Brwon \n\n        if(Vc&gt;brown_threshold_AP2P) //added\n        begin\n            tau=tau0*exp(Em*(1-abs(Id/IcAP))/(`Kb*temp*40*`M_PI));\n            if(Vc&gt;brown_threshold_AP2P) \n            begin\n                if (Vc&lt;0.8*IcAP*Rap)\n                begin\n                    if(STO==1)\n                    begin               \n                        duration=abs($rdist_exponential(seed2, tau));\n                    end\n                    else if(STO==2)\n                    begin\n                        duration=abs($rdist_normal(seed2,tau,tau*STO_dev));\n                    end                 \n                    else\n                    begin\n                        duration=tau;\n                    end \n                    if (duration&lt;=($abstime-NAP_Pt))\n                    begin \n                        ix=0.0; \n                    end\n                    else\n                    begin\n                        ix=1.0;\n                    end\n                end\n            end\n        end\n\n    end     //end of ant-parallel state \n//-------------------------------------------------------------------------------------------------------------\n\n    I(T1,T2)&lt;+Id;           \nend  // end of transiant simulation \n\n//-------------------------------------------------------------------------------------------------------------\n\nif(Temp_var==1)\nbegin      \n    V(n1) &lt;+ ( V(T1,T2)*V(T1,T2) )/ ( 2*R*surface*lam/(thick_s-toxreal));   \n    I(n1,n2) &lt;+ V(n1,n2) / resistor;\n    I(n2) &lt;+ capacitor * (ddt(V(n2)));\nend\n\n@(final_step) begin\n//$fclose(fp);\nend\n\nend // end of the analog begin \n\nendmodule\n</code></pre>"},{"location":"out_neuron/","title":"Output Neuron","text":"Verilog-A model of Output neuron <pre><code>/*\nVerilog-A model for leaky integrate-and-fire (LIF circuit)\nAdapted from : \"The Effects of Radiation on Memristor-Based Electronic \nSpiking Neural Networks.\" Dahl, Sumedha Gandharava (2020).\n*/\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n// Start of the module\nmodule LIF_neuron(nd_In) ; //, nd_cap);\n  inout nd_In; \n // output nd_cap;\n\n//nd: node, bch: branch\n  electrical nd_In, nd_switch, nd_charge, nd_cap, nd_gnd, Vth;\n  branch (nd_In, nd_charge) bch_switch;\n  branch (nd_charge, nd_cap) bch_charge;\n  branch (nd_cap, nd_gnd) bch_discharge, bch_cap;\n\n  // LIF circuit parameters\n  parameter real Rcharge = 100e6 ; // charge resistance // 60\n  parameter real Rdischarge =200e6 ; // discharge resistance\n  parameter real Rpostdischarge = 10e3 ; // cap discharge during post spike\n  parameter real mem_vth = 60e-3;        // neuron membrane potential threshold \n\n  // circuit connecting and disconnecting parameters\n  parameter real Ron = 0 ; // connection valid, current flowing\n  parameter real Roff = 1e300; // connection invalid, no current flowing\n\n  //variables used\n  real state, tfire, t, res_discharge, res_switch, V_fire;\n  real membrane;\n\n  // Start of the analog\n  analog begin\n    membrane = V(nd_cap);\n    V(nd_gnd) &lt;+ 0;\n    V(Vth) &lt;+ mem_vth; \n\n    // Start of the analysis\n    if (analysis(\"ic\")) begin\n      state = 0;\n      res_discharge = Roff;\n      res_switch = Ron;\n      //V_fire = 0;\n\n    end else begin\n      V(nd_switch) &lt;+ V(nd_In); // separate circuit and LIF circuit\n      V(bch_switch) &lt;+ I(bch_switch) * res_switch; // (dis)connect LIC circuit\n      V(bch_charge) &lt;+ I(bch_charge) * Rcharge; // charges the LIF capacitor\n      V(bch_discharge) &lt;+ I(bch_discharge) * res_discharge; // discharges the cap\n      I(bch_cap) &lt;+ 300e-12*ddt(V(bch_cap));    //C =300pF\n\n      // if vcap &lt; vth, post-synaptic neuron is not firing\n      if ((V(nd_cap) &lt; V(Vth)) &amp;&amp; (state == 0)) begin\n        tfire = $abstime;\n        res_switch = Ron; // connect LIC circuit\n\n        if (V(nd_In) &lt; V(nd_cap)) begin\n          res_discharge = Rdischarge; // turn on cap discharge\n          res_switch = Roff; // disconnect LIC circuit\n        end\n      end\n      // if vcap &gt; vth, post-synaptic neuron starts firing\n      else begin\n        res_discharge = Rpostdischarge; // turn on cap discharge\n        res_switch = Roff; // disconnect LIC circuit\n        state = 1; // set state to 1 for firing\n        t = $abstime - tfire; // start timer for pulse width\n\n        // start of the LIF spike\n        // Potentiaion part\n        if (t &lt;= (0.5e-6)) begin\n           V_fire = -100e-3/0.5e-6*t+150e-3;\n           V(nd_In) &lt;+ V_fire;\n        end\n        else if ((t &gt; 0.5e-6 ) &amp;&amp; (t &lt;= 6.5e-6)) begin\n           V_fire = -100e-3; \n           V(nd_In) &lt;+ V_fire;\n        end\n        else if ((t &gt; 6.5e-6 ) &amp;&amp; (t &lt;= 7e-6)) begin\n           V_fire = (100e-3/0.5e-6)*(t-7e-6);\n           V(nd_In) &lt;+ V_fire;\n        end\n        // Depression part \n        else if ((t &gt; 7e-6 ) &amp;&amp; (t &lt;= 7.2e-6)) begin\n           V_fire = (100e-3/0.2e-6) * (t-7e-6);\n           V(nd_In) &lt;+ V_fire;\n        end\n        else if ((t &gt; 7.2e-6 ) &amp;&amp; (t &lt;= 8.2e-6)) begin\n           V_fire = 100e-3; \n           V(nd_In) &lt;+ V_fire;\n        end\n        else if ((t &gt; 8.2e-6 ) &amp;&amp; (t &lt;= 8.4e-6)) begin\n           V_fire = (100e-3/0.2e-6)*(-t+8.4e-6);\n           V(nd_In) &lt;+ V_fire;\n        end\n        //TODO: refractory period\n        else begin\n           // Reset the voltage and set other variables\n           V_fire = 0;\n           V(nd_In) &lt;+ V_fire;\n           res_discharge = Roff; // turn off cap discharge\n           res_switch = Ron; // turn on LIC switch\n           state = 0; // set state to 0 for not firing\n        end\n\n      end // post-synaptic neuron ends firing\n\n    end // End of the analysis\n   end // End of the analog\nendmodule // End of the module\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>A guide to using the SNN Simulator framework is provided here. It covers setting up the SNN design and simulation parameters, launching the simulations, and plotting the results. For the requirements, you only need <code>Candence Spectre</code> licence instaled, along with <code>python3</code> with <code>numpy</code> and <code>matplotlib</code> packages. As of the current development of the project, no specific PDK is required.  </p>"},{"location":"usage/#setting-up-simulations","title":"Setting Up Simulations","text":""},{"location":"usage/#step-1-configuring-the-design-simulation-parameters","title":"Step 1: Configuring the design &amp; Simulation Parameters","text":"<p>The SNN design and simulation parameters are configured in the <code>snn_simulator.py</code> script. Here, you can specify the number of input and output neurons, the number of MTJs per synapse, the spike duration, and other simulation-specific parameters.</p> <p>Example configuration in <code>snn_simulator.py</code>:</p> <pre><code># Chosen design parameters\nvariables = {\n    'sim_time': 150e-3,\n    'spike_duration': 10e-3,\n    'mem_vth': 12e-3,\n    'num_input': 25,\n    'num_output': 1,\n    'num_cells': 2,\n    'cod_base': 3,\n    'cod_max': 10,\n    'inp_img': 'U',\n    'dev': 0\n}\n\n# Prepare combinations to run multiprocessing simulations\nparam_combinations = []\n\ninputs = ['I', 'O', 'C', 'F', 'H', 'K', 'L', 'P', 'T', 'U', 'X']\ndeviation = [i / 100 for i in range(0, 25, 5)]\nmtjs = [2, 4, 6, 8]\n\nfor a in inputs:\n    for b in deviation:\n        for c in mtjs:\n            variables['inp_img'] = a\n            variables['dev'] = b\n            variables['num_cells'] = c\n            param_combinations.append(variables.copy())\n</code></pre> <p>In this example, we create combinations of different inputs, number of MTJs composing a synapse, and diffrent standard deviations for variability distributions in the synapses. Each combination of these parameters represents a unique SNN design that will be simulated in parallel. In this case, <code>param_combinations</code> will have a length of 220, corresponding to the number of SNN that will simulated simultanuously. </p>"},{"location":"usage/#step-2-running-the-simulation","title":"Step 2: Running the Simulation","text":"<p>Run the <code>snn_simulator.py</code> script from <code>snn_simulator/src/</code> directory to start the simulations. We recommand creating a separate directory for the simulation results outside of the project, like <code>../../snn_sim_folders</code>. The framework will automatically create different folders in that directory for each simulation configuration. Each folder will contain the generated netlist, the updated <code>.ocn</code> script, and a <code>results.txt</code> file with the simulation results.</p> <p><pre><code>&gt;&gt; python snn_simulator.py\n</code></pre> Each run of <code>python snn_simulator.py</code> will execute the created SNN design simulations in parallel. The only limitation of the number of concurrent simulations will be the available number of CPU threads. If the number of simulations exceeds the available threads, the additional simulations will queue and start as soon as a CPU thread becomes available.</p>"},{"location":"usage/#structure-of-simulation-result-folders","title":"Structure of Simulation Result Folders","text":"<p>Each simulation generates SNN folders in the <code>../../snn_sim_folders</code> directory with a specific naming convention. The folder names are automatically generated to include the date and time when the simulation was started, process ID of the simulation run, followed by the explored parameters in that simulation, in our previous example that owuld be : tletter (input image), variability std, and the number of MTJs (cells). The general format for naming the simulation result folders is:</p> <p><code>dat_&lt;date&gt;_&lt;time&gt;_pross&lt;process_id&gt;_param1&lt;param1value&gt;_param2&lt;param2value&gt;.../</code></p> <p>Example: </p> <pre><code>dat_1225_1719_pross_48757_letX_dev0.15_cells8\ndat_1225_1721_pross_48748_letX_dev0.15_cells2\ndat_1225_1721_pross_48760_letX_dev0.0_cells2\n</code></pre> <p>Each of these simulation folders corresponds to a certain SNN design and contains the <code>netlist</code> files, <code>updated_template.ocn</code> script, and <code>results.txt</code> file containing the history of the weights of synapses and the output neuron membrane potential.</p> <pre><code>dat_1225_1719_pross_48757_letX_dev0.15_cells8/\n\u251c\u2500\u2500 netlist\n\u251c\u2500\u2500 netlist_ocn\n\u2502   \u251c\u2500\u2500 input.scs\n\u2502   \u251c\u2500\u2500 netlist\n\u2502   \u251c\u2500\u2500 netlistFooter\n\u2502   \u251c\u2500\u2500 netlistHeader\n\u251c\u2500\u2500 results.txt\n\u2514\u2500\u2500 updated_template.ocn\n</code></pre>"},{"location":"usage/#plotting-the-results","title":"Plotting the Results","text":""},{"location":"usage/#plotting-weight-and-membrane-potential","title":"Plotting Weight and Membrane Potential","text":"<p>The <code>plot_weig_membr.py</code> script reads the simulation results from the <code>results.txt</code> file in a specified folder. It then plots the history of the synaptic weights and the membrane potential of the output neuron over the course of the simulation. It also displays a reconstructed image of the synapses states before and after training.  </p>"},{"location":"usage/#usage_1","title":"Usage","text":"<pre><code>&gt;&gt; python plot_weig_membr.py &lt;simulation_folder&gt;\n</code></pre>"},{"location":"usage/#plotting-euclidean-distance","title":"Plotting Euclidean Distance","text":"<p>The <code>plot_eucl_dist.py</code> script evaluates the training quality of the synapses by calculating and plotting the Euclidean distance between the input pattern and the synapse conductance pattern after training. This metric is used because the small network is trained on one pattern at a time, making accuracy measures less relevant. By comparing the states of the synapses after training under various variability conditions, the script visualizes the impact of variability on synaptic learning. This analysis can be extended to different SNN configurations using different numbers of MTJs per synapse.</p>"},{"location":"usage/#usage_2","title":"Usage","text":"<pre><code>&gt;&gt; python plot_eucl_dist.py\n</code></pre>"},{"location":"workflow/","title":"Simulation Workflow","text":"<p>The framework's architecture which is summarized in Figure 1 is modular. Each module is geared towards simplifying and automating the complex processes involved in SNN design, training, and analysis. The scripts of the framework work together to perform simulations and analysis of the SNN, with the main Python script (<code>snn_simulator.py</code>) coordinating the flow between the following components:</p> <ol> <li> <p>First, the <code>gen_letters.py</code> script generates images of various letters for training. Using a specific script to generate personalized images allow us to control the complexity and size of training dataset, each image is saved as <code>.npy</code> file in the <code>letter_imgs</code> directory. Additionally, it saves a dictionary of all images in a pickle file for later use. There is also a possibility to train the network with images from MNIST. for that, a small set of MNIST images should first be extracted using <code>extract_mnist.py</code> and optionally visualize it using <code>see_image.py</code>. Thes scripts and the generated images are organized in <code>input_images</code> directory from which the simulator loads the inputs.</p> </li> <li> <p>Next, the main script (<code>snn_simulator.py</code>) orchestrates the entire simulation process. It sets up simulation parameters, prepares combinations for multiprocessing, and runs the simulations in parallel using the <code>run_simulation</code> function. This function loads the generated <code>.npy</code> image files and flattens them to create input data for the SNN simulation. These images represent the spiking neurons' intensity, which is used to configure the neuron inputs. The user is requested to input design and simulation options in this main script. Subsequently, design choices such as the number of input and output neurons and the synapse composition are handed to <code>net_generator.py</code> to generate the netlist. Similarly, simulation options such as step, duration and file paths are handed to <code>subst_run.py</code> to prepare the ocean script that should be executed. It might be worth highlighting the parallel processing capability of the framework, this means that we can train many SNNs with different sizes and design parameters at the same time, with a complete separation between the input and output files of each SNN, and with no intervention from the user.</p> </li> <li> <p>The <code>net_generator.py</code> script is responsible for generating the netlist file required for the simulation. It uses various classes to define components of the SNN, such as synapses, input neurons, and output neurons. These components are assembled into a complete netlist file, which includes references to the Verilog-A models. If different SNN sizes are requested to run in parallel, the main script tells the netlist generator to output each <code>netlist</code> in a different simulation directory.</p> </li> <li> <p>The <code>subst_run.py</code> script contains utility functions for substituting values into templates and executing shell commands. The main script uses <code>subst_run.substitute_templ</code> to replace placeholders in the <code>oceanScript.ocn</code> template with actual values from the simulation parameters. It then uses <code>subst_run.exec_cmd</code> to run the simulation commands using the substituted script (final Ocean script) and the generated netlist. In short, the script <code>subst_run.py</code> has two functions: first, it prepares the final ocean script by substituting the user-defined parameters in a generic template (<code>oceanScript.ocn</code>). Second, it executes shell commands to run the simulation. This substitution method is inspired by the approach used in monaco project by @servinagrero.</p> </li> <li> <p>The <code>oceanScript.ocn</code> file is an OCEAN script used by the Cadence Spectre simulator to set up and run a transient analysis for the SNN simulation. It specifies the design file, analysis parameters, environment options, and variables, and it controls the simulation flow and data saving. This script is crucial for defining how the simulation should be run and what data should be saved.</p> </li> <li> <p>The Verilog-A models (<code>in_neuron.va</code>, <code>out_neuron.va</code>, and <code>mtj_model.va</code>) define the behavior of the different components in the SNN. The <code>in_neuron.va</code> file models the input neurons that generate spikes, the <code>out_neuron.va</code> file models the output neurons with leaky integrate-and-fire behavior, and the <code>mtj_model.va</code> file models the PMA MTJ based on the STT mechanism. These models are included in the netlist and are used by the simulator to simulate the electrical behavior of the SNN.</p> </li> <li> <p>After the simulations are run, the <code>plot_weig_membr.py</code> script reads the output data (<code>results.txt</code>) produced by the simulations. It uses <code>matplotlib</code> to plot the weights history and membrane potentials of the neurons during training, providing a visual representation of the simulation results. These visualizations are saved as PDF files for further analysis. If the simulations consists of variability study od the SNN, <code>plot_eucl_dist.py</code> allows to evaluate the resiliance of the netwok against the variability. In fact, it calculates the euclidian destance between the weights of a dependable SNN and the weights of an ideal one, it then plots the euclidian distnaces with respect to the dependability magnitude (standard deviation of the variability distribution, injected defects values, ...) </p> </li> </ol> <p>In summary, the process starts with generating input images using <code>gen_letters.py</code>, which are then used by <code>snn_simulator.py</code> to set up and run simulations. The <code>net_generator.py</code> script creates the necessary netlist files, while <code>subst_run.py</code> substitutes parameters in the <code>oceanScript.ocn</code> template and executes the simulation commands. The Verilog-A models define the behavior of the SNN components, and the <code>plot_weig_membr.py</code> script visualizes the simulation results. This integrated workflow allows for efficient simulation and analysis of SNNs.</p> <p>The following diagram summurises every file involved in the simulaiton of SNN online training and it output visualisation, and how they interact in an automatic way. </p> <p></p> <p>Figure 1: Overview of the SNN Training Framework detailing module interactions and data flow.</p>"}]}